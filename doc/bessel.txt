Simple patterns

Simple patterns are defined by an optional binder followed by a type
or an expression. Simple patterns always have '@'.


Type patterns

  Type patterns always have an '@' followed by a monotype.

  id '@' Type
     '@' Type

  x@Int
    guard: isInt
    binds: x = toInt

  x@Real
    guard: isReal
    binds: x = toReal

  x@[Int]
    guard:  isSeq isInt
    binds: x = toSeq toInt

   @Int
     guard: isInt
     no binds

   ...


Expression patterns

  Predicate patterns always have '@' followed by an expression.  This
  expression can be either a qualified name denoting a predicate, or a
  complex expression with predicate type.

  id '@' '(' Expr ')
     '@' '(' Expr ')'
  id '@' QualName
     '@' QualName
  id '@'
     '@'

  x@(y@ (y > 0))
    guard: y@ (y > 0)
    binds: x = id

   @(y@ (y > 0))
    guard: y@ (y > 0)
    no binds

  x@isInt
    guard: isInt
    binds: x = id

  y@isReal
    guard: isReal
    binds: x = id

   @isBool
    guard: isBool
    no binds

  x@
    guard: const true
    binds: x = id

   @
    guard: const true
    binds: no binds


Complex patterns

Complex patterns are defined by an optional binder followed by a
pattern or a combined pattern. Complex patterns have '@' only when a
name is being defined.


ListPat: List patterns

  List patterns have '@' only when a name is being defined.

  id '@' '[' Pat ']'
         '[' Pat ']'
         '[' ']'

  
  [x@isInt, xs@[y@isReal, z@isBool]]


CombPat: Combined patterns

  Combined patterns have '@' only when a name is being defined.

  id '@' '(' Pat +> Pat ')'
  id '@' '(' Pat <+ Pat ')'
  id '@' '(' Pat && Pat ')'
  id '@' '(' Pat || Pat ')'
         '(' Pat +> Pat ')'
         '(' Pat <+ Pat ')'
         '(' Pat && Pat ')'
         '(' Pat || Pat ')'

  def f (x@isInt +> xs@[Int]) = ...
